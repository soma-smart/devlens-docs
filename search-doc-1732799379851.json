{"searchDocs":[{"title":"Dataiku","type":0,"sectionRef":"#","url":"/doc-devlens/Where is my project/Dataiku","content":"","keywords":"","version":"Next"},{"title":"Interactive mode​","type":1,"pageTitle":"Dataiku","url":"/doc-devlens/Where is my project/Dataiku#interactive-mode","content":" During the steps, you will need to provide your Dataiku Instance name (usually your organization name) and your Dataiku project key path (usually your project name):    ","version":"Next","tagName":"h2"},{"title":"Command mode​","type":1,"pageTitle":"Dataiku","url":"/doc-devlens/Where is my project/Dataiku#command-mode","content":" ./devlens --dataiku-instance yourdataikuinstancename \\ --dataiku-project-key yourdataikuprojectkey  ","version":"Next","tagName":"h2"},{"title":"Basic pack","type":0,"sectionRef":"#","url":"/doc-devlens/Annotators/Basic pack","content":"","keywords":"","version":"Next"},{"title":"List of annotators available in basic pack​","type":1,"pageTitle":"Basic pack","url":"/doc-devlens/Annotators/Basic pack#list-of-annotators-available-in-basic-pack","content":" ","version":"Next","tagName":"h2"},{"title":"Python​","type":1,"pageTitle":"Basic pack","url":"/doc-devlens/Annotators/Basic pack#python","content":" FROM IMPORT: Identifies 'from ... import ...' statements in Python code.IMPORT: Identifies 'import ...' statements in Python code.GET ENV: Identifies 'os.getenv' calls in Python code.PYTHON HADOOP TABLE: Identifies Hadoop table references in Python code.SPARK TABLE ENV: Identifies 'spark.table()' references in Python code.  ","version":"Next","tagName":"h3"},{"title":"SparkSQL​","type":1,"pageTitle":"Basic pack","url":"/doc-devlens/Annotators/Basic pack#sparksql","content":" ENV VAR IN TABLE NAME: Identifies environment variables in table names within Spark SQL queries.GET TABLE: Identifies environment-specific table names in Spark SQL queries.SELECT NO WHERE: Identifies SQL SELECT statements that do not contain a WHERE clause.SELECT WILDCARD: Identifies instances where a wildcard (*) is used in the SELECT clause. ","version":"Next","tagName":"h3"},{"title":"Annotation","type":0,"sectionRef":"#","url":"/doc-devlens/How it works/Annotation","content":"","keywords":"","version":"Next"},{"title":"Annotation​","type":1,"pageTitle":"Annotation","url":"/doc-devlens/How it works/Annotation#annotation","content":" The next step is to &quot;catch&quot; the node you want. Binaries in the release come with an 'annotators/' folder already filled with some examples.  Here is an example of the Annotator that will store every import of your project:  class PythonImportAnnotator(AbstractAnnotator): &quot;&quot;&quot; PythonImportAnnotator is an annotator class that identifies import statements in Python code. &quot;&quot;&quot; def parse(self, ast: ParserRuleContext): importStmts = findAll(ast, &quot;Import_stmt&quot;) importNames = findAll(importStmts, &quot;Import_name&quot;) names = findAll(importNames, &quot;Dotted_name&quot;) for match in names: yield Annotation(name=&quot;Import&quot;, value=self.getText(match), context=match)   What interests us in this example is mostly the use of the findAll() method. This method will create a list of every node you want in the AST.  You just have to use the findAll() on each node you want to filter until you get the value of the node.  Here is the AST that represent an import:  File_input └── Statements └── Statement └── Simple_stmts └── Simple_stmt └── Import_stmt └── Import_name └── 'import' └── Dotted_as_names └── Dotted_as_name └── Dotted_name └── 'dataiku' └── '   In the annotator we get every Dotted_name nested in every Import_name nested in every Import_stmt. Filtering this way make the annotator as much precise as possible, so it will not get another unrelated node.  The last part is to create an Annotation for each match you have. You can choose to not store a value in the Annotation by passing None to the annotation.  Executing a check will result in the creation of Annotations and the filling of the database.   ","version":"Next","tagName":"h2"},{"title":"Kubernetes","type":0,"sectionRef":"#","url":"/doc-devlens/How to get projects variables/Kubernetes","content":"","keywords":"","version":"Next"},{"title":"Kubernetes secrets​","type":1,"pageTitle":"Kubernetes","url":"/doc-devlens/How to get projects variables/Kubernetes#kubernetes-secrets","content":" Devlens can retrieve your Kubernetes secrets in a specified namespace by providing your values.yaml and your kubeconfig path in your bash command.  The values.yaml file (or any other config Helm file you specify) needs to have two keys so Devlens can find your secrets: namespace and secret.  You will need a kubeconfig file and a helm deployment file.  # values.yaml namespace: devlens-cli secret: enabled: true ref: - secretRef: name: database   The purpose of this functionality is to substitute your local project environment variables with their values stored in Kubernetes secrets.  For example, if you need to ensure that a file only uses one specific environment variable for the Database:  import os import spark test1 = spark.table(&quot;PRD_DB_MET_BBBB.SC_PARAM_MET.TABLE1&quot;) test2 = spark.table(os.getenv(&quot;DATABASE&quot;) + &quot;_DB_MET_BBBB.SC_PARAM_MET.TABLE2&quot;)   A basic annotator could retrieve the PRD from the first DB name but would not get the value of DATABASE.  That's why we created a system that substitutes os.getenv statements with their values held in a Kubernetes secret.  This means that the annotation will get the swapped values for you.  During the steps, you will need to provide your project folder path, your deployment file path (usually your Helm values.yaml file), and your kubeconfig path (usually located under ~/.kube/config):    Now we can query the DB to check swapped values!   ","version":"Next","tagName":"h2"},{"title":"Abstract Syntax Tree","type":0,"sectionRef":"#","url":"/doc-devlens/How it works/Abstract Syntax Tree","content":"","keywords":"","version":"Next"},{"title":"The heart of DEVLENS​","type":1,"pageTitle":"Abstract Syntax Tree","url":"/doc-devlens/How it works/Abstract Syntax Tree#the-heart-of-devlens","content":" Thanks to ANTLR4 parsers, we create ASTs that provide enough information to find which nodes hold the information we want. The main purpose of this logic is to modulate DEVLENS to accept any language as input. Annotators are not created based on the reference of a file but directly on syntax trees.  ","version":"Next","tagName":"h2"},{"title":"Abstract Syntax Tree (AST)​","type":1,"pageTitle":"Abstract Syntax Tree","url":"/doc-devlens/How it works/Abstract Syntax Tree#abstract-syntax-tree-ast","content":" An Abstract Syntax Tree (AST) is a tree representation of the syntactic structure of source code. Each node represents a construct occurring in the code, such as expressions or statements, allowing for structured analysis and manipulation of the code.  For example, this block represents the tree of a Python import. &quot;Import_Stmt&quot; is the first node that interests us to filter every import in the code. Then the value of the import is located under the &quot;Dotted_name&quot; node:  For an original code that look like this:  //... import dataiku from pyspark import SparkContext from pyspark.sql import SQLContext sc = SparkContext.getOrCreate() sqlContext = SQLContext(sc) //...   We can see how the AST display import  #ast_local.txt File_input └── Statements └── Statement └── Simple_stmts └── Simple_stmt └── Import_stmt └── Import_name └── 'import' └── Dotted_as_names └── Dotted_as_name └── Dotted_name └── 'dataiku' └── '   ","version":"Next","tagName":"h2"},{"title":"interactive mode​","type":1,"pageTitle":"Abstract Syntax Tree","url":"/doc-devlens/How it works/Abstract Syntax Tree#interactive-mode","content":" To generate an AST through our interactive terminal, you can directly choose the correct option and specify the folder you want to analyze:    DEVLENS will analyze every file you have in the folder, create an AST, and store it in a file at the root of where you executed the binary:    Accessing this file will give you a general view of every node of your project, sorted by file.  //... downloads/soma/DEVLENS/recipes/compute_toto.py File_input └── Statements └── Statement └── Simple_stmts └── Simple_stmt └── Import_stmt └── Import_name └── 'import' └── Dotted_as_names └── Dotted_as_name └── Dotted_name └── 'dataiku' └── ' └── Statement └── Simple_stmts └── Simple_stmt └── Import_stmt └── Import_from └── 'from' └── Dotted_name └── 'pyspark' └── 'import' └── Import_from_targets └── Import_from_as_names └── Import_from_as_name └── 'SparkContext' └── ' //...   ","version":"Next","tagName":"h2"},{"title":"command mode​","type":1,"pageTitle":"Abstract Syntax Tree","url":"/doc-devlens/How it works/Abstract Syntax Tree#command-mode","content":" You can also generate an AST in command mode:  ./devlens check /downloads --only-ast  ","version":"Next","tagName":"h2"},{"title":"Devlens in CI","type":0,"sectionRef":"#","url":"/doc-devlens/Devlens in CI","content":"","keywords":"","version":"Next"},{"title":"Example CI​","type":1,"pageTitle":"Devlens in CI","url":"/doc-devlens/Devlens in CI#example-ci","content":" name: Use Devlens on: push: branches: - main pull_request: branches: - main jobs: use_devlens: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 # Make sure to specify the right version and dist of the release you want and also the right. - name: Download Devlens release run: | version=&quot;0.3.4&quot; curl -s https://api.github.com/repos/soma-smart/dev-devlens-cli/releases/latest \\ | jq -r '.assets[] | select(.name | contains(&quot;ubuntu-latest-3.12.tar.gz&quot;)) | .browser_download_url' \\ | xargs -n 1 curl -L -o devlens.tar.gz - name: Extract Devlens run: tar -xzvf devlens.tar.gz - name: Make Devlens executable run: chmod +x devlens - name: Run Devlens run: ./devlens check . # This the query check if DEVLENS has annoted your project well. - name: Query DB and check results run: | result_count=$(./devlens query &quot;SELECT COUNT(*) FROM your_table WHERE your_conditions;&quot; | tail -n 1) if [ &quot;$result_count&quot; -eq 0 ]; then echo &quot;Problem detected: No results found.&quot; exit 1 else echo &quot;No problems detected: $result_count results found.&quot; fi # This is the query you want to change to check you results. - name: Set SQL query variables run: | export SQL_QUERY=&quot;SELECT COUNT(*) FROM another_table WHERE other_conditions;&quot; - name: Query DB and check results run: | result_count=$(./devlens query &quot;$SQL_QUERY&quot; | tail -n 1) if [ &quot;$result_count&quot; -gt 0 ]; then echo &quot;Problem detected: $result_count results found.&quot; exit 1 else echo &quot;No problems detected.&quot; fi  ","version":"Next","tagName":"h2"},{"title":"Local","type":0,"sectionRef":"#","url":"/doc-devlens/Where is my project/Local","content":"","keywords":"","version":"Next"},{"title":"Interactive Mode​","type":1,"pageTitle":"Local","url":"/doc-devlens/Where is my project/Local#interactive-mode","content":" Just follow the steps in the interactive mode:    ","version":"Next","tagName":"h2"},{"title":"Command Mode​","type":1,"pageTitle":"Local","url":"/doc-devlens/Where is my project/Local#command-mode","content":" Or you can also use the command mode:  ./devlens check downloads/  ","version":"Next","tagName":"h2"},{"title":"How to query","type":0,"sectionRef":"#","url":"/doc-devlens/How to query","content":"","keywords":"","version":"Next"},{"title":"Interactive mode​","type":1,"pageTitle":"How to query","url":"/doc-devlens/How to query#interactive-mode","content":" After the analysis, you can query your annotations directly from your terminal:    ","version":"Next","tagName":"h2"},{"title":"Command mode​","type":1,"pageTitle":"How to query","url":"/doc-devlens/How to query#command-mode","content":" If you prefer to use the command mode, you can execute the query command directly:  ./devlens query &quot;SELECT value FROM annotation WHERE name='Import'&quot;   This command will result in an output directly on the terminal.   ","version":"Next","tagName":"h2"},{"title":"Dataiku","type":0,"sectionRef":"#","url":"/doc-devlens/How to get projects variables/Dataiku","content":"Dataiku Dataiku Project Variables Devlens can retrieve your project variables directly from your cloud easily: Each time you initiate a Dataiku analysis, Devlens will check if there are any project variables available.Then an annotator can use the values to perform any process you want. For example, the ENV VAR IN TABLE NAME annotator is able to annotate any portion of an SQL clause where there is an environment variable in the table name. It will give you the value of that variable directly in the annotation.","keywords":"","version":"Next"},{"title":"Usage Command","type":0,"sectionRef":"#","url":"/doc-devlens/Usage command","content":"","keywords":"","version":"Next"},{"title":"Download DEVLENS​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#download-devlens","content":" DEVLENS is available in the release section of the documentation repository:  https://github.com/soma-smart/doc-devlens/releases  When you extract DEVLENS, be sure to get the ANNOTATORS FOLDER unless you have your own.    ","version":"Next","tagName":"h2"},{"title":"Interactive mode​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#interactive-mode","content":" DEVLENS provides an easy and accessible Interactive mode that will give you a cool step-by-step UI in the terminal to do everything you need.  To launch the interactive mode, use the --interactive flag:  ./devlens --interactive     ","version":"Next","tagName":"h2"},{"title":"Command mode​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#command-mode","content":" DEVLENS also comes in &quot;command&quot; mode where you can use flags to launch various commands:  To see the command mode you can simply execute:  ./devlens     ","version":"Next","tagName":"h2"},{"title":"Local Check​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#local-check","content":" ./devlens check yourfolder/   ","version":"Next","tagName":"h3"},{"title":"Local Check + Kubernetes secrets​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#local-check--kubernetes-secrets","content":" ./devlens check yourfolder/ \\ --deployment-file yourdeploymentfilepath \\ --kubeconfig yourkubeconfigpath   ","version":"Next","tagName":"h3"},{"title":"Dataiku Check​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#dataiku-check","content":" ./devlens --dataiku-instance yourdataikuinstancename \\ --dataiku-project-key yourdataikuprojectkey   ","version":"Next","tagName":"h3"},{"title":"Dataiku download locally your project​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#dataiku-download-locally-your-project","content":" ./devlens --dataiku-instance yourdataikuinstancename \\ --dataiku-project-key yourdataikuprojectkey \\ --project-file-download   ","version":"Next","tagName":"h3"},{"title":"Query​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#query","content":" ./devlens query &quot;SELECT ...&quot;   ","version":"Next","tagName":"h3"},{"title":"Replace​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#replace","content":" ./devlens replace yourpath/ --query &quot;SELECT * FROM ...&quot; \\ --replace-type yourtype \\ --replace-logic yourlogic \\   path: The path to the directory or file to analyze and perform replacements.--query: The SQL query to select the annotations to replace.--replace-type: The type of replacement to perform. Options are: simple: Perform a straightforward string replacement.logic: Perform a replacement based on SQL logic. --replace-pattern: The pattern to search for in simple replacements.--replace-value: The value to replace the pattern with in simple replacements.--replace-logic: The SQL logic for dynamic replacements.  ","version":"Next","tagName":"h3"},{"title":"Make DEVLENS globally available​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#make-devlens-globally-available","content":" If you want to use devlens anywhere on your machine, you might want to make it available globally:  sudo mv ./devlens /usr/local/bin/ sudo chmod +x /usr/local/bin/devlens  ","version":"Next","tagName":"h2"},{"title":"How to replace","type":0,"sectionRef":"#","url":"/doc-devlens/How to replace","content":"","keywords":"","version":"Next"},{"title":"Simple Replacement​","type":1,"pageTitle":"How to replace","url":"/doc-devlens/How to replace#simple-replacement","content":" A simple replacement involves directly replacing a specified pattern with a new value. This is useful for straightforward text substitutions.  Before:  insert into DEV (SELECT * FROM DEV)   After:  insert into PROD (SELECT * FROM PROD)   ","version":"Next","tagName":"h2"},{"title":"Interactive Mode​","type":1,"pageTitle":"How to replace","url":"/doc-devlens/How to replace#interactive-mode","content":" In interactive mode, you can visually select the text you want to replace and specify the new value.      ","version":"Next","tagName":"h3"},{"title":"Command Mode​","type":1,"pageTitle":"How to replace","url":"/doc-devlens/How to replace#command-mode","content":" In command mode, you can use the following command to perform the replacement:  python main.py replace downloads/ \\ --query &quot;SELECT * FROM annotation WHERE name='table_env'&quot; \\ --replace-type simple \\ --replace-pattern &quot;DEV&quot; \\ --replace-value &quot;PROD&quot;   ","version":"Next","tagName":"h3"},{"title":"Logic Replacement​","type":1,"pageTitle":"How to replace","url":"/doc-devlens/How to replace#logic-replacement","content":" A logic-based replacement uses SQL logic to perform more complex substitutions. This is useful when the replacement depends on the content or structure of the text.  This is why Devlens provides a more precise way to change what you want in code.  The logic replacement takes three flags:  --query: The query to filter your result by annotation.--replace-type: Set with the value logic.--replace-logic: Your custom SQL logic.  For example, a logic replacement to change every hdfs://HDFS_SERVER:3543 to s3a:// can be done as follows:  Before:  expected_df = ( spark.read.parquet(&quot;hdfs://HDFS_SERVER:3543/finance/pib/expected/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) .withColumnRenamed(&quot;pib&quot;, &quot;expected_pib&quot;) ) actual_df = ( spark.read.csv(&quot;hdfs://HDFS_SERVER:3543/finance/pib/expected/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) )   After:  expected_df = ( spark.read.parquet(&quot;s3a://finance/pib/expected/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) .withColumnRenamed(&quot;pib&quot;, &quot;expected_pib&quot;) ) actual_df = ( spark.read.csv(&quot;s3a://finance/pib/expected/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) )     The annotation made on spark.read expression holds the complete value of the parameter, so a simple replacement cannot work.  We need to provide Devlens with a SQL replacement logic.    By using the logic way, we are able to modify code without replacing a whole value.  ","version":"Next","tagName":"h2"},{"title":"Command Mode​","type":1,"pageTitle":"How to replace","url":"/doc-devlens/How to replace#command-mode-1","content":" If you want to use the command mode:  python main.py replace downloads/ \\ --query &quot;SELECT * FROM annotation WHERE name='spark_read'&quot; \\ --replace-type logic \\ --replace-logic &quot;REPLACE(value, 'hdfs://HDFS_SERVER:3543/', 's3a://')&quot;  ","version":"Next","tagName":"h3"},{"title":"Examples","type":0,"sectionRef":"#","url":"/doc-devlens/Examples","content":"","keywords":"","version":"Next"},{"title":"Don't use SELECT *​","type":1,"pageTitle":"Examples","url":"/doc-devlens/Examples#dont-use-select-","content":" #example.sql insert into DEV_DB_AAAA.SC_PARAM_AAAA.TABLE_AAAA (SELECT * FROM REC_DB_BBBB.SC_PARAM_AAAA.TABLE_AAAA)   To be sure there isn't any SELECT * in your whole project, an annotator can find every occurrence of Wildcard in your code:  from annotators.common.abstract_annotator import AbstractAnnotator from annotators.common.search import findAll from annotators.common.annotation import Annotation from antlr4 import ParserRuleContext class SparkSQLSelectWildcard(AbstractAnnotator): def parse(self, ast: ParserRuleContext): selectClause = findAll(ast, &quot;SelectClause&quot;) namedExpressionSeq = findAll(selectClause, &quot;NamedExpressionSeq&quot;) star = findAll(namedExpressionSeq, &quot;Star&quot;) for match in star: yield Annotation( name=&quot;Select_Wildcard&quot;, context=match, )   You can then query your database to check if this annotator found any SELECT *:  SELECT path FROM annotation WHERE name= &quot;Select_Wildcard&quot;      ","version":"Next","tagName":"h2"},{"title":"Don't use different DB environments in the same file​","type":1,"pageTitle":"Examples","url":"/doc-devlens/Examples#dont-use-different-db-environments-in-the-same-file","content":" Be sure the same environment is used in each file. You can create an annotator that will get every DB environment of your project:  #example.py from annotators.common.abstract_annotator import AbstractAnnotator from annotators.common.search import findAll from annotators.common.annotation import Annotation from antlr4 import ParserRuleContext ENV_LIST = [&quot;DEV&quot;, &quot;INT&quot;, &quot;REC&quot;, &quot;PRD&quot;] class SparkSQLTableEnv(AbstractAnnotator): def parse(self, ast: ParserRuleContext): fromClause = findAll(ast, &quot;FromClause&quot;) tableNames = findAll(fromClause, &quot;TableName&quot;) multipartIdentifier1 = findAll(tableNames, &quot;MultipartIdentifier&quot;) insertInto = findAll(ast, &quot;InsertIntoTable&quot;) multipartIdentifier2 = findAll(insertInto, &quot;MultipartIdentifier&quot;) all_names = multipartIdentifier1 + multipartIdentifier2 for match in all_names: starting_str = self.getText(match).split(&quot;_&quot;)[0].upper() if starting_str in ENV_LIST: yield Annotation(name=&quot;Table_Env&quot;, value=starting_str, context=match)   Then you can query the Devlens DB:  SELECT path FROM annotation WHERE name = 'Table_Env' AND name IN ( SELECT name FROM annotation WHERE name = 'Table_Env' GROUP BY name HAVING COUNT(DISTINCT value) &gt; 1) ORDER BY path;   This query will display every file where there is more than one environment used.     ","version":"Next","tagName":"h2"},{"title":"Use right dependencies​","type":1,"pageTitle":"Examples","url":"/doc-devlens/Examples#use-right-dependencies","content":" It's hard to list every dependency used in a project:  #example.py import dataiku from pyspark import SparkContext from pyspark.sql import SQLContext from snowflake.snowpark import Session from snowflake.snowpark.functions import * from snowflake.snowpark.exceptions import SnowparkSQLException import snowflake_package from snowflake.snowpark.types import * sc = SparkContext.getOrCreate() sqlContext = SQLContext(sc) USER = str(Path.home()).split(&quot;/&quot;)[-1] try: connection = snowflake_package.get_connection( key_path=f&quot;{Path.home()}/.secure/{USER}_snowflake.pem&quot;, warehouse=&quot;WH_TEST&quot;) except: connection = snowflake_package.get_connection( key_path=f&quot;{Path.home()}/.secure/snowflake.p8&quot;, warehouse=&quot;WH_TEST&quot;)   An annotator can retrieve every dependency importation in a project:  from annotators.common.abstract_annotator import AbstractAnnotator from annotators.common.search import findAll from annotators.common.annotation import Annotation from antlr4 import ParserRuleContext class PythonFromImportAnnotator(AbstractAnnotator): def parse(self, ast: ParserRuleContext): importStmts = findAll(ast, &quot;Import_stmt&quot;) importFroms = findAll(importStmts, &quot;Import_from&quot;) for importFrom in importFroms: names = findAll(importFrom, &quot;Dotted_name&quot;) importFromAsNames = findAll(importFrom, &quot;Import_from_as_name&quot;) module = names[0].getText() for submodule in importFromAsNames: yield Annotation( name=&quot;From_Import&quot;, value=module + &quot;.&quot; + submodule.getText(), context=submodule, )   You can then query the Devlens DB:  SELECT value FROM annotation WHERE name = &quot;From_Import&quot;;      ","version":"Next","tagName":"h2"},{"title":"Retrieve your Environment variable directly from your Kubernetes secrets​","type":1,"pageTitle":"Examples","url":"/doc-devlens/Examples#retrieve-your-environment-variable-directly-from-your-kubernetes-secrets","content":" Devlens is able to retrieve your environment variable automatically just by giving your config file path:  You will need a kubeconfig file and a helm deployment file.    An annotator finding every os.getenv will help you display your Kubernetes secrets:  from annotators.common.abstract_annotator import AbstractAnnotator from annotators.common.search import findAll from annotators.common.annotation import Annotation from antlr4 import ParserRuleContext class PythonGetenvAnnotator(AbstractAnnotator): def parse(self, ast: ParserRuleContext): getenv_calls = findAll(ast, &quot;Primary&quot;, filters={&quot;primary&quot;: &quot;os.getenv&quot;}) arguments = findAll(getenv_calls, &quot;Arguments&quot;) strings = findAll(arguments, &quot;Strings&quot;) for match in strings: yield Annotation(name=&quot;os_getenv&quot;, value=self.getText(match), context=match)   Then you can query the Devlens DB:  SELECT path, value FROM annotation WHERE name='os.getenv';     For example, when you are doing a full upgrade of your application and need to be sure you swapped every old version of a function;  Devlens can analyze your whole project and tell you exactly in which file and which lines are your old code.  You found something you want to change globally in your project? Use the Replace to modify your whole project with values you want.  Devlens can be integrated seamlessly into your development process since it also works directly in your CI!  It also integrates a Dataiku connection to retrieve easily your project from any Dataiku instance!  ","version":"Next","tagName":"h2"},{"title":"Replace 'HDFS' to 'S3'​","type":1,"pageTitle":"Examples","url":"/doc-devlens/Examples#replace-hdfs-to-s3","content":" To migrate from HDFS to S3 in your project by changing every occurrence of 'hdfs://' to 's3a://':  #example.py from pyspark.sql import SparkSession from pyspark.sql import functions as F spark = SparkSession.builder.getOrCreate() expected_df = ( spark.read.parquet(&quot;hdfs://HDFS_SERVER:3543/finance/pib/expected/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) .withColumnRenamed(&quot;pib&quot;, &quot;expected_pib&quot;) ) actual_df = ( spark.read.csv(&quot;hdfs://HDFS_SERVER:3543/finance/pib/actual/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) ) ///.... spark.stop()   An annotator can find every spark.read you have:  from annotators.common.abstract_annotator import AbstractAnnotator from annotators.common.annotation import Annotation from annotators.common.search import findAll from antlr4 import ParserRuleContext class SparkReadParquetAnnotator(AbstractAnnotator): def parse(self, ast: ParserRuleContext): spark_read = findAll( ast, &quot;Primary&quot;, filters={&quot;primary&quot;: &quot;spark.read.parquet&quot;} ) spark_read += findAll( ast, &quot;Primary&quot;, filters={&quot;primary&quot;: &quot;spark.read.csv&quot;} ) arguments = findAll(spark_read, &quot;Arguments&quot;) strings = findAll(arguments, &quot;Strings&quot;) for expr in strings: yield Annotation( name=&quot;spark_read&quot;, value=self.getText(expr), context=expr )   Then with the Devlens replace command, you can change every occurrence directly in your terminal:    Then you can check on your code:  #example.py from pyspark.sql import SparkSession from pyspark.sql import functions as F spark = SparkSession.builder.getOrCreate() expected_df = ( spark.read.parquet(&quot;s3a://finance/pib/expected/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) .withColumnRenamed(&quot;pib&quot;, &quot;expected_pib&quot;) ) actual_df = ( spark.read.parquet(&quot;s3a://finance/pib/actual/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) )  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}