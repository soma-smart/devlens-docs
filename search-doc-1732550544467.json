{"searchDocs":[{"title":"How to query","type":0,"sectionRef":"#","url":"/doc-devlens/How to query","content":"","keywords":"","version":"Next"},{"title":"interactive mode​","type":1,"pageTitle":"How to query","url":"/doc-devlens/How to query#interactive-mode","content":" After the analyze, you can query your Annotations directly from you terminal :    ","version":"Next","tagName":"h2"},{"title":"classic mode​","type":1,"pageTitle":"How to query","url":"/doc-devlens/How to query#classic-mode","content":" If you prefer to use the Classic mode (We won't be mad if you do :) ), you can execute directly the query command :  ./devlens query &quot;SELECT value from annotation Where name='Import'&quot;   This command will result on a output directly on the terminal.   ","version":"Next","tagName":"h2"},{"title":"Dataiku","type":0,"sectionRef":"#","url":"/doc-devlens/Where is my project/Dataiku","content":"","keywords":"","version":"Next"},{"title":"interactive mode​","type":1,"pageTitle":"Dataiku","url":"/doc-devlens/Where is my project/Dataiku#interactive-mode","content":" During the steps you will need to provide your your Dataiku Instance name (usually your organisation name) and your dataiku project key path (usually your project name) :    ","version":"Next","tagName":"h2"},{"title":"classic mode​","type":1,"pageTitle":"Dataiku","url":"/doc-devlens/Where is my project/Dataiku#classic-mode","content":" ./devlens --dataiku-instance yourdataikuinstancename --dataiku-project-key yourdataikuprojectkey  ","version":"Next","tagName":"h2"},{"title":"Local","type":0,"sectionRef":"#","url":"/doc-devlens/Where is my project/Local","content":"","keywords":"","version":"Next"},{"title":"interactive mode​","type":1,"pageTitle":"Local","url":"/doc-devlens/Where is my project/Local#interactive-mode","content":" Just follow the steps in the interactive mode:    ","version":"Next","tagName":"h2"},{"title":"classic mode​","type":1,"pageTitle":"Local","url":"/doc-devlens/Where is my project/Local#classic-mode","content":" Or you can also use the classic mode:  ./devlens check downloads/  ","version":"Next","tagName":"h2"},{"title":"Basic pack","type":0,"sectionRef":"#","url":"/doc-devlens/Annotators/Basic pack","content":"","keywords":"","version":"Next"},{"title":"List of annotators available in basic pack​","type":1,"pageTitle":"Basic pack","url":"/doc-devlens/Annotators/Basic pack#list-of-annotators-available-in-basic-pack","content":" ","version":"Next","tagName":"h2"},{"title":"Python​","type":1,"pageTitle":"Basic pack","url":"/doc-devlens/Annotators/Basic pack#python","content":" FROM IMPORT: Identifies 'from ... import ...' statements in Python code.IMPORT: Identifies 'import ...' statements in Python code.GET ENV: Identifies 'os.getenv' calls in Python code.PYTHON HADOOP TABLE: Identifies Hadoop table references in Python code.SPARK TABLE ENV: Identifies 'spark.table()' reference in Python code.  ","version":"Next","tagName":"h3"},{"title":"SparkSQL​","type":1,"pageTitle":"Basic pack","url":"/doc-devlens/Annotators/Basic pack#sparksql","content":" ENV VAR IN TABLE NAME: Identifies environment variables in table names within a Spark SQL queries.GET TABLE: Identifies environment-specific table names in Spark SQL queries.SELECT NO WHERE: Identifies SQL SELECT statements that do not contain a WHERE clause.SELECT WILDCARD: identifies instances where a wildcard (*) is used in the SELECT clause. ","version":"Next","tagName":"h3"},{"title":"Annotation","type":0,"sectionRef":"#","url":"/doc-devlens/How it works/Annotation","content":"","keywords":"","version":"Next"},{"title":"Annotation​","type":1,"pageTitle":"Annotation","url":"/doc-devlens/How it works/Annotation#annotation","content":" The next step is to &quot;catch&quot; the node you want. Binaries in the release comes with an 'annotators/' folder already filled with some example.  Here is an example of the Annotator that will store every import of your project :  class PythonImportAnnotator(AbstractAnnotator): &quot;&quot;&quot; PythonImportAnnotator is an annotator class that identifies import statements in Python code. &quot;&quot;&quot; def parse(self, ast: ParserRuleContext): &quot;&quot;&quot; Methods: -------- parse(ast: ParserRuleContext): Parses the provided AST to find and yield annotations for Python import statements. It searches for import statements, import names, and dotted names within the AST. Parameters: ----------- ast : ParserRuleContext The abstract syntax tree to be parsed for import statements. Yields: ------- Annotation An annotation object containing the name &quot;Import&quot;, the value of the import statement, and the context in which the import statement was found. &quot;&quot;&quot; importStmts = findAll(ast, &quot;Import_stmt&quot;) importNames = findAll(importStmts, &quot;Import_name&quot;) names = findAll(importNames, &quot;Dotted_name&quot;) for match in names: yield Annotation(name=&quot;Import&quot;, value=self.getText(match), context=match)   What interest us in this example is mostly the use of findAll() method. This method will create a list of every node you want in the AST.  You just have to use the findAll() on each node you want to filter until you get the value of the node.  The last part is to create an Annotation for each match you have. You can choose to not store a value in the Annotation by passing None to the annotation.  Executing a check will result on the creation of Annotations and the filling of the database.   ","version":"Next","tagName":"h2"},{"title":"Abstract Syntax Tree","type":0,"sectionRef":"#","url":"/doc-devlens/How it works/Abstract Syntax Tree","content":"","keywords":"","version":"Next"},{"title":"The heart of DEVLENS​","type":1,"pageTitle":"Abstract Syntax Tree","url":"/doc-devlens/How it works/Abstract Syntax Tree#the-heart-of-devlens","content":" Thanks to ANTLR4 parsers, we create ASTs that give enough informations to find which nods hold informations we want. The main purpose of this logic is to modulate DEVLENS to accept any language as input. Annotators are not created on reference of file but directly on syntax trees.  ","version":"Next","tagName":"h2"},{"title":"Abstract Syntax Tree (AST)​","type":1,"pageTitle":"Abstract Syntax Tree","url":"/doc-devlens/How it works/Abstract Syntax Tree#abstract-syntax-tree-ast","content":" An Abstract Syntax Tree (AST) is a tree representation of the syntactic structure of source code. Each node represents a construct occurring in the code, such as expressions or statements, allowing for structured analysis and manipulation of the code.  For example, this block represent the tree of a Python import.&quot;Import_Stmt&quot; is the first node that interest us to filter every import in code. Then value of the import is located under the &quot;Dotted_name&quot; node :    ","version":"Next","tagName":"h2"},{"title":"Generate an AST​","type":1,"pageTitle":"Abstract Syntax Tree","url":"/doc-devlens/How it works/Abstract Syntax Tree#generate-an-ast","content":" To generate an AST through our interactive terminal you can directly choose the correct option, and specify the folder you want to analyze :    DEVLENS will analyze every file you have in the folder, create an AST and store it in a file at the root of where you executed the binary :    Accessing this file will give you a general view of every node of your project, sorted by file.   ","version":"Next","tagName":"h3"},{"title":"Kubernetes","type":0,"sectionRef":"#","url":"/doc-devlens/How to get projects variables/Kubernetes","content":"","keywords":"","version":"Next"},{"title":"Kubernetes secrets​","type":1,"pageTitle":"Kubernetes","url":"/doc-devlens/How to get projects variables/Kubernetes#kubernetes-secrets","content":" Devlens can retreive your kubernetes secrets on a aimed namespace by giving your values.yaml and your kubeconfig path in your bash command.  The values.yaml file (or any other config Helm file you specifies) need to have two key so Devlens can find your secrets : namespace and secret.    The purpose of that functionnality is to substitut your local project environnement variables by their value stocked in kube secret.  For example if you need to be sure that a file only use one specific env for Database:  import os import spark test1=spark.table(&quot;PRD_DB_MET_BBBB.SC_PARAM_MET.TABLE1&quot;) test2=spark.table(os.getenv(&quot;DATABASE&quot;) + &quot;_DB_MET_BBBB.SC_PARAM_MET.TABLE2&quot;)   A basic Annotator could retreive the PRD from the first DB name but would not get the value of DATABASE.  That why we created a system that substitut os.getenv statement with their value holded in a kube secret.  That mean that Annotation will get the swapped values for you.  During the steps you will need to provide your project folder path, your deployement file path (usually your helm values.yaml file) and your kubeconfig path (usually located under ~/.kube/config) :    Now we can can query the DB to check swapped Values !   ","version":"Next","tagName":"h2"},{"title":"Dataiku","type":0,"sectionRef":"#","url":"/doc-devlens/How to get projects variables/Dataiku","content":"Dataiku Dataiku project variables Devlens can retreive your projects variables directly from your cloud easily: Each time you initiate a dataiku analyze , Devlens will check if there is any Project variables availables.Then an annotator can use the values to do any process you want. For example, the ENV VAR IN TABLE NAME annotators is able to annotate any portion of SQL clause where there is a Environnement variables in the table name. It will give you the value of that variables directly in the annotation","keywords":"","version":"Next"},{"title":"How to replace","type":0,"sectionRef":"#","url":"/doc-devlens/How to replace","content":"","keywords":"","version":"Next"},{"title":"interactive mode​","type":1,"pageTitle":"How to replace","url":"/doc-devlens/How to replace#interactive-mode","content":" Imagine you want to add _MAIN to all your db environnement in your project:  Just by using the interactive mode you can specify which annotations are relevant and give your replacement logic in SQL :    You can instantly see the change right after:    You will also have a new table create in database to identifies every change done on your project:    ","version":"Next","tagName":"h2"},{"title":"replacement statement​","type":1,"pageTitle":"How to replace","url":"/doc-devlens/How to replace#replacement-statement","content":" The replacement Statement take 3 parameter separated by ||.  The first parameter is the sql column you are looking to changeThe second parameter is the new valueThe third parameter is the replacement logic  ","version":"Next","tagName":"h3"},{"title":"classic mode​","type":1,"pageTitle":"How to replace","url":"/doc-devlens/How to replace#classic-mode","content":" If you want to use the classic mod, you can use the --replace flag, followed by the full instruction of replacement:  python main.py query &quot;SELECT * FROM annotation WHERE name='Table_Env'&quot; --replace &quot;value || '_MAIN' || SUBSTR(original, 4)&quot;  ","version":"Next","tagName":"h2"},{"title":"Devlens in CI","type":0,"sectionRef":"#","url":"/doc-devlens/Devlens in CI","content":"","keywords":"","version":"Next"},{"title":"Example CI​","type":1,"pageTitle":"Devlens in CI","url":"/doc-devlens/Devlens in CI#example-ci","content":" name: Use Devlens on: push: branches: - main pull_request: branches: - main jobs: use_devlens: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 # Make sure to specify the right version and dist of the release you want and also the right. - name: Download Devlens release run: | version=&quot;0.3.0&quot; curl -s https://api.github.com/repos/soma-smart/dev-devlens-cli/releases/latest \\ | jq -r '.assets[] | select(.name | contains(&quot;ubuntu-latest-3.12.tar.gz&quot;)) | .browser_download_url' \\ | xargs -n 1 curl -L -o devlens.tar.gz - name: Extract Devlens run: tar -xzvf devlens.tar.gz - name: Make Devlens executable run: chmod +x devlens - name: Run Devlens run: ./devlens check . # This the query check if DEVLENS has annoted your project well. - name: Query DB and check results run: | result_count=$(./devlens query &quot;SELECT COUNT(*) FROM your_table WHERE your_conditions;&quot; | tail -n 1) if [ &quot;$result_count&quot; -eq 0 ]; then echo &quot;Problem detected: No results found.&quot; exit 1 else echo &quot;No problems detected: $result_count results found.&quot; fi # This is the query you want to change to check you results. - name: Set SQL query variables run: | export SQL_QUERY=&quot;SELECT COUNT(*) FROM another_table WHERE other_conditions;&quot; - name: Query DB and check results run: | result_count=$(./devlens query &quot;$SQL_QUERY&quot; | tail -n 1) if [ &quot;$result_count&quot; -gt 0 ]; then echo &quot;Problem detected: $result_count results found.&quot; exit 1 else echo &quot;No problems detected.&quot; fi  ","version":"Next","tagName":"h2"},{"title":"Usage Command","type":0,"sectionRef":"#","url":"/doc-devlens/Usage command","content":"","keywords":"","version":"Next"},{"title":"Download DEVLENS​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#download-devlens","content":" DEVLENS is available in release section of the documentation repository :  https://github.com/soma-smart/devlens-docs/releases  When you extract DEVLENS, be sure to get also the ANNOTATORS FOLDER unless you have your owns.    ","version":"Next","tagName":"h2"},{"title":"Interactive mode​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#interactive-mode","content":" DEVLENS provide an easy and accessible Interactive mode that will give you a cool step-by-step UI in terminal to do everything you need.  To launch the interactive mode, use the --interactive flag :  ./devlens --interactive     ","version":"Next","tagName":"h2"},{"title":"Classic mode​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#classic-mode","content":" DEVLENS also come in &quot;classic&quot; mode where you can use flag to lauch various command:  To see the classic mode you can simply execute :  ./devlens     ","version":"Next","tagName":"h2"},{"title":"Local Check​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#local-check","content":" ./devlens check yourfolder/   ","version":"Next","tagName":"h3"},{"title":"Local Check + Kubernetes secrets​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#local-check--kubernetes-secrets","content":" ./devlens check youfolder/ --deployment-file yourdeploymentfilepath --kubeconfig yourkubeconfigpath   ","version":"Next","tagName":"h3"},{"title":"Dataiku Check​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#dataiku-check","content":" ./devlens --dataiku-instance yourdataikuinstancename --dataiku-project-key yourdataikuprojectkey   ","version":"Next","tagName":"h3"},{"title":"Dataiku download locally your project​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#dataiku-download-locally-your-project","content":" ./devlens --dataiku-instance yourdataikuinstancename --dataiku-project-key yourdataikuprojectkey --project-file-download   ","version":"Next","tagName":"h3"},{"title":"Query​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#query","content":" ./devlens query &quot;SELECT ....&quot;   Replace  python main.py replace downloads/ &quot;SELECT * FROM annotation WHERE name='Table_Env'&quot; --replace &quot;value || 'replacement' || logic&quot;   ","version":"Next","tagName":"h3"},{"title":"Make DEVLENS globally available​","type":1,"pageTitle":"Usage Command","url":"/doc-devlens/Usage command#make-devlens-globally-available","content":" If you want to use devlens anywhere on your machine, you might want to make it available globally :  sudo mv ./devlens /usr/local/bin/ sudo chmod +x /usr/local/bin/devlens  ","version":"Next","tagName":"h2"},{"title":"Example","type":0,"sectionRef":"#","url":"/doc-devlens/Example","content":"","keywords":"","version":"Next"},{"title":"Don't use SELECT *​","type":1,"pageTitle":"Example","url":"/doc-devlens/Example#dont-use-select-","content":" If you want to be sure there isn't any SELECT * in your whole project , an annotator can find every occurence of Wildcard in your code:  from annotators.common.abstract_annotator import AbstractAnnotator from annotators.common.search import findAll from annotators.common.annotation import Annotation from antlr4 import ParserRuleContext class SparkSQLSelectWildcard(AbstractAnnotator): def parse(self, ast: ParserRuleContext): selectClause = findAll(ast, &quot;SelectClause&quot;) namedExpressionSeq = findAll(selectClause, &quot;NamedExpressionSeq&quot;) star = findAll(namedExpressionSeq, &quot;Star&quot;) for match in star: yield Annotation( name=&quot;Select_Wildcard&quot;, context=match, )   You can then query your database to check if this annotator found any SELECT *:  SELECT path FROM annotation WHERE name= &quot;Select_Wildcard&quot;      ","version":"Next","tagName":"h2"},{"title":"Don't use different DB environnement in the same file​","type":1,"pageTitle":"Example","url":"/doc-devlens/Example#dont-use-different-db-environnement-in-the-same-file","content":" If you want to be sure the same environnement is used in each file you can create a annotator that will get every db env of your project:  from annotators.common.abstract_annotator import AbstractAnnotator from annotators.common.search import findAll from annotators.common.annotation import Annotation from antlr4 import ParserRuleContext ENV_LIST = [&quot;DEV&quot;, &quot;INT&quot;, &quot;REC&quot;, &quot;PRD&quot;] class SparkSQLTableEnv(AbstractAnnotator): def parse(self, ast: ParserRuleContext): fromClause = findAll(ast, &quot;FromClause&quot;) tableNames = findAll(fromClause, &quot;TableName&quot;) multipartIdentifier1 = findAll(tableNames, &quot;MultipartIdentifier&quot;) insertInto = findAll(ast, &quot;InsertIntoTable&quot;) multipartIdentifier2 = findAll(insertInto, &quot;MultipartIdentifier&quot;) all_names = multipartIdentifier1 + multipartIdentifier2 for match in all_names: starting_str = self.getText(match).split(&quot;_&quot;)[0].upper() if starting_str in ENV_LIST: yield Annotation(name=&quot;Table_Env&quot;, value=starting_str, context=match)   Then you can query the Devlens DB:  SELECT path FROM annotation WHERE name = 'Table_Env' AND name IN (SELECT name FROM annotation WHERE name = 'Table_Env' GROUP BY name HAVING COUNT(DISTINCT value) &gt; 1)ORDER BY path;   `  ","version":"Next","tagName":"h2"},{"title":"Use right dependencies​","type":1,"pageTitle":"Example","url":"/doc-devlens/Example#use-right-dependencies","content":" An annotator can retreive every dependencies importation in a project:  from annotators.common.abstract_annotator import AbstractAnnotator from annotators.common.search import findAll from annotators.common.annotation import Annotation from antlr4 import ParserRuleContext class PythonFromImportAnnotator(AbstractAnnotator): def parse(self, ast: ParserRuleContext): importStmts = findAll(ast, &quot;Import_stmt&quot;) importFroms = findAll(importStmts, &quot;Import_from&quot;) for importFrom in importFroms: names = findAll(importFrom, &quot;Dotted_name&quot;) importFromAsNames = findAll(importFrom, &quot;Import_from_as_name&quot;) module = names[0].getText() for submodule in importFromAsNames: yield Annotation( name=&quot;From_Import&quot;, value=module + &quot;.&quot; + submodule.getText(), context=submodule, )   You can then query the Devlens DB :  SELECT value FROM annotation WHERE name = &quot;From_Import&quot;;      ","version":"Next","tagName":"h2"},{"title":"Retrieve your Environnement variable directly from your Kubernetes secrets​","type":1,"pageTitle":"Example","url":"/doc-devlens/Example#retrieve-your-environnement-variable-directly-from-your-kubernetes-secrets","content":" Devlens is able to retreive your environnement variable automatically just by giving your config file path:    Then you can query the Devlens DB:  SELECT path,value FROM annotation WHERE name='os.getenv';     Imagine you are doing a full upgrade of your application and need to be sure you swapped every old version of a function;  Devlens can analyze your whole project and tell you exactly in which file and which lines are your old code.  You found something you want to change globally in your project ? use the Replace to modify you whole projet with values you want.  Devlens can be integrated seamless in your developpement process since it also work directly in your CI!  It also integrate a Dataiku connection to retreive easily your project from any dataiku instance !  ","version":"Next","tagName":"h2"},{"title":"Replace 'HDFS' to 'S3'​","type":1,"pageTitle":"Example","url":"/doc-devlens/Example#replace-hdfs-to-s3","content":" Imagine you want to migrate from HDFS to S3 in your project by changing every occurence of 'hdfs://' by 's3a://':   from pyspark.sql import SparkSession from pyspark.sql import functions as F spark = SparkSession.builder.getOrCreate() expected_df = ( spark.read.parquet(&quot;hdfs://HDFS_SERVER:3543/finance/pib/expected/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) .withColumnRenamed(&quot;pib&quot;, &quot;expected_pib&quot;) ) actual_df = ( spark.read.csv(&quot;hdfs://HDFS_SERVER:3543/finance/pib/actual/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) ) ///.... spark.stop()   An annotator can find every spark.read you have:  from annotators.common.abstract_annotator import AbstractAnnotator from annotators.common.annotation import Annotation from annotators.common.search import findAll from antlr4 import ParserRuleContext class SparkReadParquetAnnotator(AbstractAnnotator): def parse(self, ast: ParserRuleContext): spark_read = findAll( ast, &quot;Primary&quot;, filters={&quot;primary&quot;: &quot;spark.read.parquet&quot;} ) spark_read += findAll( ast, &quot;Primary&quot;, filters={&quot;primary&quot;: &quot;spark.read.csv&quot;} ) arguments = findAll(spark_read, &quot;Arguments&quot;) strings = findAll(arguments, &quot;Strings&quot;) for expr in strings: yield Annotation( name=&quot;spark_read&quot;, value=self.getText(expr), context=expr )   Then with the Devlens replace command, you can change every occurence directly in your terminal    Then you can check on your code:   from pyspark.sql import SparkSession from pyspark.sql import functions as F spark = SparkSession.builder.getOrCreate() expected_df = ( spark.read.parquet(&quot;s3a://finance/pib/expected/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) .withColumnRenamed(&quot;pib&quot;, &quot;expected_pib&quot;) ) actual_df = ( spark.read.parquet(&quot;s3a://finance/pib/actual/&quot;) .withColumn(&quot;year&quot;, F.year(&quot;date&quot;)) )  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}